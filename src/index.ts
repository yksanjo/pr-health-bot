import * as core from '@actions/core';
import * as github from '@actions/github';

interface PRSizeCategory {
  label: string;
  emoji: string;
  threshold: number;
}

interface HealthCheckResult {
  size: {
    totalLines: number;
    category: PRSizeCategory;
  };
  description: {
    exists: boolean;
  };
  tests: {
    found: boolean;
    files: string[];
  };
}

const SIZE_THRESHOLDS: PRSizeCategory[] = [
  { label: 'Small', emoji: 'ğŸŸ¢', threshold: 200 },
  { label: 'Medium', emoji: 'ğŸŸ¡', threshold: 400 },
  { label: 'Large', emoji: 'ğŸ”´', threshold: Infinity },
];

function categorizePRSize(totalLines: number): PRSizeCategory {
  if (totalLines <= SIZE_THRESHOLDS[0].threshold) {
    return SIZE_THRESHOLDS[0];
  } else if (totalLines <= SIZE_THRESHOLDS[1].threshold) {
    return SIZE_THRESHOLDS[1];
  } else {
    return SIZE_THRESHOLDS[2];
  }
}

function checkForTests(files: { filename: string }[]): { found: boolean; files: string[] } {
  const testFiles: string[] = [];
  
  for (const file of files) {
    const filename = file.filename.toLowerCase();
    const isTestFile = 
      filename.includes('test') ||
      filename.endsWith('.test.js') ||
      filename.endsWith('.test.ts') ||
      filename.endsWith('.test.jsx') ||
      filename.endsWith('.test.tsx') ||
      filename.endsWith('.spec.js') ||
      filename.endsWith('.spec.ts') ||
      filename.endsWith('.spec.jsx') ||
      filename.endsWith('.spec.tsx');
    
    if (isTestFile) {
      testFiles.push(file.filename);
    }
  }
  
  return {
    found: testFiles.length > 0,
    files: testFiles,
  };
}

function generateComment(result: HealthCheckResult): string {
  const { size, description, tests } = result;
  
  let comment = 'ğŸ§ª **PR Health Report**\n\n';
  comment += 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n';
  
  // Size section
  comment += `**PR Size:** ${size.totalLines} lines â€” ${size.category.emoji} ${size.category.label}\n`;
  if (size.category.label === 'Large') {
    comment += '*Large PRs slow down review and increase bugs.*\n';
  }
  comment += '\n';
  
  // Description section
  if (description.exists) {
    comment += `**Description:** âœ… Provided\n\n`;
  } else {
    comment += `**Description:** âŒ None Provided\n`;
    comment += '*Please add context so reviewers understand the purpose.*\n\n';
  }
  
  // Tests section
  if (tests.found) {
    comment += `**Tests Added:** âœ… ${tests.files.length} test file(s) found\n`;
    if (tests.files.length <= 3) {
      comment += `*Files: ${tests.files.join(', ')}*\n`;
    }
    comment += '\n';
  } else {
    comment += `**Tests Added:** âš ï¸ No tests found\n`;
    comment += '*Consider adding test coverage for new logic.*\n\n';
  }
  
  comment += '---\n\n';
  comment += 'Generated by **PR Health Bot**';
  
  return comment;
}

async function findExistingComment(
  octokit: ReturnType<typeof github.getOctokit>,
  owner: string,
  repo: string,
  prNumber: number
): Promise<number | null> {
  const { data: comments } = await octokit.rest.issues.listComments({
    owner,
    repo,
    issue_number: prNumber,
  });
  
  // Find comment that starts with our signature
  const botComment = comments.find(comment => 
    comment.body?.includes('ğŸ§ª **PR Health Report**')
  );
  
  return botComment ? botComment.id : null;
}

async function run(): Promise<void> {
  try {
    const token = core.getInput('github-token', { required: true });
    const octokit = github.getOctokit(token);
    
    const context = github.context;
    
    if (context.eventName !== 'pull_request' && context.eventName !== 'pull_request_target') {
      core.setFailed('This action only works on pull_request events');
      return;
    }
    
    const pr = context.payload.pull_request;
    if (!pr) {
      core.setFailed('No pull request found in context');
      return;
    }
    
    const owner = context.repo.owner;
    const repo = context.repo.repo;
    const prNumber = pr.number;
    
    core.info(`Analyzing PR #${prNumber}...`);
    
    // Get PR files
    const { data: files } = await octokit.rest.pulls.listFiles({
      owner,
      repo,
      pull_number: prNumber,
    });
    
    // Calculate PR size
    const totalLines = files.reduce((sum, file) => sum + file.additions + file.deletions, 0);
    const sizeCategory = categorizePRSize(totalLines);
    
    // Check description
    const hasDescription = pr.body && pr.body.trim().length > 0;
    
    // Check for tests
    const testCheck = checkForTests(files);
    
    const healthCheck: HealthCheckResult = {
      size: {
        totalLines,
        category: sizeCategory,
      },
      description: {
        exists: hasDescription,
      },
      tests: {
        found: testCheck.found,
        files: testCheck.files,
      },
    };
    
    // Generate comment
    const commentBody = generateComment(healthCheck);
    
    // Find existing comment or create new one
    const existingCommentId = await findExistingComment(octokit, owner, repo, prNumber);
    
    if (existingCommentId) {
      core.info('Updating existing comment...');
      await octokit.rest.issues.updateComment({
        owner,
        repo,
        comment_id: existingCommentId,
        body: commentBody,
      });
      core.info('Comment updated successfully');
    } else {
      core.info('Creating new comment...');
      await octokit.rest.issues.createComment({
        owner,
        repo,
        issue_number: prNumber,
        body: commentBody,
      });
      core.info('Comment created successfully');
    }
    
    core.setOutput('pr-size', totalLines);
    core.setOutput('has-description', hasDescription);
    core.setOutput('has-tests', testCheck.found);
    
  } catch (error) {
    if (error instanceof Error) {
      core.setFailed(error.message);
    } else {
      core.setFailed('Unknown error occurred');
    }
  }
}

run();

